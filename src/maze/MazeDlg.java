//
// MazeDlg.java
// Implements the dialog to define and display a rectangular oe circular maze.
//

package maze;

import java.awt.BasicStroke;
import java.awt.Graphics;
import java.awt.Rectangle;
import java.awt.Color;
import java.awt.Graphics2D;
import java.awt.Point;
import java.awt.Stroke;
import java.util.Iterator;
import javax.swing.JOptionPane;
import maze.Maze.Walls;

//
// Main maze Dialog class
public class MazeDlg extends javax.swing.JFrame {

    /**
     * Creates new form MazeDlg
     */
    public MazeDlg() {
        initComponents();
        
        // Set the initial state of the components
        jRectButton.setSelected(true);
        jHelpText.setText(RectHelp);
        textRadials.setEnabled(false);
        textLayers.setEnabled(false);
    }
    
    // Get details of the maze to be generated
    private boolean GetMazeParams() {
        int width;
        int height;
        
        // If rectangular
        if (jRectButton.isSelected()) {
            // Get and validate the width and height
            try {
                width = Integer.parseInt(textWidth.getText());
                height = Integer.parseInt(textHeight.getText());
            } catch (NumberFormatException e) {
                JOptionPane.showMessageDialog(null, "Width and Height must be numeric values");
                return false;
            }
            
            if (width < 5 || width > 25 || height < 5 || height > 25) {
                JOptionPane.showMessageDialog(null, "Width and Height must be numeric values in range 5 to 25");
                return false;
            }
        } else {
            // If circular, get and valiadte the radials and layers
            try {
                width = Integer.parseInt(textRadials.getText());
                height = Integer.parseInt(textLayers.getText());
            } catch (NumberFormatException e) {
                JOptionPane.showMessageDialog(null, "Radials and Layers must be numeric values");
                return false;
            }
            
            if (width < 15 || width > 30 || height < 4 || height > 8) {
                JOptionPane.showMessageDialog(null, "radials must be between 15 and 30 and Layers must be bettwen 4 and 8");
                return false;
            }
        }
        maze.setSize(width, height);
        return true;
    }

    /**
     * This method is called from within the constructor to initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is always
     * regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        buttonGroup1 = new javax.swing.ButtonGroup();
        jLabel1 = new javax.swing.JLabel();
        textWidth = new java.awt.TextField();
        jLabel2 = new javax.swing.JLabel();
        textHeight = new java.awt.TextField();
        btnCreate = new java.awt.Button();
        chkShowSolution = new java.awt.Checkbox();
        jPanel1 = new MazeView();
        jRectButton = new javax.swing.JRadioButton();
        jCircButton = new javax.swing.JRadioButton();
        jLabel3 = new javax.swing.JLabel();
        textRadials = new java.awt.TextField();
        jLabel4 = new javax.swing.JLabel();
        textLayers = new java.awt.TextField();
        jHelpText = new javax.swing.JLabel();
        btn3D = new java.awt.Button();

        setDefaultCloseOperation(javax.swing.WindowConstants.EXIT_ON_CLOSE);

        jLabel1.setText("Width:");

        textWidth.setText("15");

        jLabel2.setText("Height:");

        textHeight.setText("15");

        btnCreate.setLabel("Create");
        btnCreate.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                btnCreateActionPerformed(evt);
            }
        });

        chkShowSolution.setLabel("Show Solution");
        chkShowSolution.addItemListener(new java.awt.event.ItemListener() {
            public void itemStateChanged(java.awt.event.ItemEvent evt) {
                chkShowSolutionItemStateChanged(evt);
            }
        });

        jPanel1.setBackground(new java.awt.Color(255, 255, 255));
        jPanel1.setBorder(javax.swing.BorderFactory.createBevelBorder(javax.swing.border.BevelBorder.RAISED));

        javax.swing.GroupLayout jPanel1Layout = new javax.swing.GroupLayout(jPanel1);
        jPanel1.setLayout(jPanel1Layout);
        jPanel1Layout.setHorizontalGroup(
            jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGap(0, 550, Short.MAX_VALUE)
        );
        jPanel1Layout.setVerticalGroup(
            jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGap(0, 0, Short.MAX_VALUE)
        );

        buttonGroup1.add(jRectButton);
        jRectButton.setText("Rectangular");
        jRectButton.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jRectButtonActionPerformed(evt);
            }
        });

        buttonGroup1.add(jCircButton);
        jCircButton.setText("Circular");
        jCircButton.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jCircButtonActionPerformed(evt);
            }
        });

        jLabel3.setText("Radials");

        textRadials.setEnabled(false);
        textRadials.setText("30");

        jLabel4.setText("Layers");

        textLayers.setEnabled(false);
        textLayers.setText("6");

        jHelpText.setText("jHelpText");

        btn3D.setEnabled(false);
        btn3D.setLabel("3D");
        btn3D.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                btn3DActionPerformed(evt);
            }
        });

        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(getContentPane());
        getContentPane().setLayout(layout);
        layout.setHorizontalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addContainerGap()
                .addComponent(jPanel1, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addGroup(layout.createSequentialGroup()
                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                            .addGroup(layout.createSequentialGroup()
                                .addGap(18, 18, 18)
                                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                                    .addComponent(jCircButton)
                                    .addComponent(jRectButton))
                                .addGap(0, 0, Short.MAX_VALUE))
                            .addGroup(layout.createSequentialGroup()
                                .addGap(27, 27, 27)
                                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                                    .addComponent(btnCreate, javax.swing.GroupLayout.PREFERRED_SIZE, 70, javax.swing.GroupLayout.PREFERRED_SIZE)
                                    .addComponent(chkShowSolution, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                                    .addComponent(btn3D, javax.swing.GroupLayout.PREFERRED_SIZE, 70, javax.swing.GroupLayout.PREFERRED_SIZE))
                                .addGap(7, 7, 7))
                            .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, layout.createSequentialGroup()
                                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                                    .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, layout.createSequentialGroup()
                                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                                            .addComponent(jLabel1)
                                            .addComponent(jLabel2))
                                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING, false)
                                            .addComponent(textWidth, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                                            .addComponent(textHeight, javax.swing.GroupLayout.PREFERRED_SIZE, 37, javax.swing.GroupLayout.PREFERRED_SIZE)))
                                    .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, layout.createSequentialGroup()
                                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                                            .addComponent(jLabel3)
                                            .addComponent(jLabel4))
                                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING, false)
                                            .addComponent(textRadials, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                                            .addComponent(textLayers, javax.swing.GroupLayout.PREFERRED_SIZE, 37, javax.swing.GroupLayout.PREFERRED_SIZE))))))
                        .addGap(34, 34, 34))
                    .addGroup(layout.createSequentialGroup()
                        .addGap(18, 18, 18)
                        .addComponent(jHelpText, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                        .addContainerGap())))
        );
        layout.setVerticalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addGroup(layout.createSequentialGroup()
                        .addGap(24, 24, 24)
                        .addComponent(jPanel1, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
                    .addGroup(layout.createSequentialGroup()
                        .addGap(33, 33, 33)
                        .addComponent(jRectButton)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)
                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING, false)
                            .addComponent(jLabel1)
                            .addComponent(textWidth, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)
                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                            .addComponent(textHeight, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                            .addComponent(jLabel2))
                        .addGap(25, 25, 25)
                        .addComponent(jCircButton)
                        .addGap(18, 18, 18)
                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING, false)
                            .addComponent(jLabel3)
                            .addComponent(textRadials, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)
                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                            .addComponent(textLayers, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                            .addComponent(jLabel4))
                        .addGap(22, 22, 22)
                        .addComponent(jHelpText, javax.swing.GroupLayout.PREFERRED_SIZE, 73, javax.swing.GroupLayout.PREFERRED_SIZE)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED, 121, Short.MAX_VALUE)
                        .addComponent(chkShowSolution, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                        .addGap(14, 14, 14)
                        .addComponent(btn3D, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(btnCreate, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)))
                .addContainerGap())
        );

        pack();
    }// </editor-fold>//GEN-END:initComponents

    // Handle the user pressing the Create button
    private void btnCreateActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_btnCreateActionPerformed
        
        // Get the maze details
        if (!GetMazeParams()) {
            return;
        }
        
        // Create the maze
        maze.CreateMaze(jCircButton.isSelected());
        btn3D.setEnabled(true);  // User can now use the 3D button
        
        // Maze is ready to draw
        jPanel1.invalidate();
        jPanel1.repaint();
    }//GEN-LAST:event_btnCreateActionPerformed

    // redraw the maze if the user selects or de-selects the show solution
    //  checkbox, the drawing function will pick up the state of this
    private void chkShowSolutionItemStateChanged(java.awt.event.ItemEvent evt) {//GEN-FIRST:event_chkShowSolutionItemStateChanged
        jPanel1.invalidate();
        jPanel1.repaint();
    }//GEN-LAST:event_chkShowSolutionItemStateChanged

    // Set the correct component state if the user presses the rectangular radio button
    private void jRectButtonActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jRectButtonActionPerformed
        jHelpText.setText(RectHelp);
        textHeight.setEnabled(true);
        textWidth.setEnabled(true);
        textLayers.setEnabled(false);
        textRadials.setEnabled(false);
        

    }//GEN-LAST:event_jRectButtonActionPerformed

    // Set the correct component state if the user presses the circular radio button
    private void jCircButtonActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jCircButtonActionPerformed
        jHelpText.setText(CircHelp);
        textHeight.setEnabled(false);
        textWidth.setEnabled(false);
        textLayers.setEnabled(true);
        textRadials.setEnabled(true);

    }//GEN-LAST:event_jCircButtonActionPerformed

    // Handle the user pressing the 3D button
    private void btn3DActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_btn3DActionPerformed
        Maze3D.create(maze);
    }//GEN-LAST:event_btn3DActionPerformed

    /**
     * Main entry point for the program (This function is NetBeans generated)
     * @param args the command line arguments
     */
    public static void main(String args[]) {
        /* Set the Nimbus look and feel */
        //<editor-fold defaultstate="collapsed" desc=" Look and feel setting code (optional) ">
        /* If Nimbus (introduced in Java SE 6) is not available, stay with the default look and feel.
         * For details see http://download.oracle.com/javase/tutorial/uiswing/lookandfeel/plaf.html 
         */
        try {
            for (javax.swing.UIManager.LookAndFeelInfo info : javax.swing.UIManager.getInstalledLookAndFeels()) {
                if ("Nimbus".equals(info.getName())) {
                    javax.swing.UIManager.setLookAndFeel(info.getClassName());
                    break;
                }
            }
        } catch (ClassNotFoundException ex) {
            java.util.logging.Logger.getLogger(MazeDlg.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (InstantiationException ex) {
            java.util.logging.Logger.getLogger(MazeDlg.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (IllegalAccessException ex) {
            java.util.logging.Logger.getLogger(MazeDlg.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (javax.swing.UnsupportedLookAndFeelException ex) {
            java.util.logging.Logger.getLogger(MazeDlg.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        }
        //</editor-fold>

        /* Create and display the form */
        java.awt.EventQueue.invokeLater(new Runnable() {
            public void run() {
                new MazeDlg().setVisible(true);
            }
        });
    }
    
    // Implement the panel which containsthe drawing code for the maze
    public class MazeView extends javax.swing.JPanel {
        
        public MazeView() {
        }
        
        // Determine the maze type and call the correct drawing function
        @Override
        public void paintComponent(Graphics g) {
            
            super.paintComponent(g);
            
            if (maze.isCreated()) {
                if (!maze.isCircular()) {
                    DrawRectangular(g);
                } else {
                    DrawCircular(g);
                }
            }
        }
        
        // Draw a circular maze
        private void DrawCircular(Graphics g) {
            //  Get the drawing rect
            g.setColor(Color.BLACK);
            Rectangle r = g.getClipBounds();
            
            // set the line width
            Graphics2D g2 = (Graphics2D) g;
            Stroke oldStroke = g2.getStroke();
            g2.setStroke(new BasicStroke(5));
            
            // Reduce the size of the clip rectangle (as that the maze is 
            //  clearly fully shown)
            int rad_offset = 8;
            r.x += rad_offset;
            r.y += rad_offset;
            r.height -= rad_offset * 2;
            r.width -= rad_offset * 2;
            
            // Get the width and height
            int width = maze.getWidth();
            int height = maze.getHeight();
            
            // Calculate the angle of a map sector
            double sect_angle = 360.0 / width;
            int x_centre = r.width / 2 + rad_offset; //  Get the centre point
            int y_centre = r.height / 2 + rad_offset;
            
            int centre_rad = 3;  // The centre is equivalent to 3 layers
            int x_sect = x_centre / (centre_rad + height);
            int y_sect = y_centre / (centre_rad + height);
            
            double deg_to_rad = (2.0 * Math.PI) / 360.0;
            
            // For each row/column of the maze
            for (int j = 0; j < height; j++) {
                for (int i = 0; i < width; i++) {
                    
                    // Draw the North wall
                    if (maze.IsWall(i, j, Walls.North)) {
                        g.drawArc(j * x_sect + rad_offset, j * y_sect + rad_offset,
                                r.width - (2 * j * x_sect), r.height - (2 * j * y_sect),
                                (int) (i * sect_angle), (int) (sect_angle + 0.5));
                    }
                    
                    // Only need to draw the south wall on the innermost wall
                    if (j == (height - 1)) {
                        if (maze.IsWall(i, j, Walls.South)) {
                            g.drawArc(height * x_sect + rad_offset, height * y_sect + rad_offset,
                                    r.width - (2 * height * x_sect),
                                    r.height - (2 * height * y_sect),
                                    (int) (i * sect_angle), (int) (sect_angle + 0.5));
                            
                        }
                    }
                    
                    // Draw the West wall
                    double angle = (double) (i * sect_angle) * deg_to_rad;
                    if (maze.IsWall(i, j, Walls.West)) {
                        // calculate the co-ordinates
                        int xrad1 = r.width / 2 - (j * x_sect);
                        int xrad2 = xrad1 - x_sect;
                        int yrad1 = r.height / 2 - (j * y_sect);
                        int yrad2 = yrad1 - y_sect;
                        
                        int x1 = (int) (Math.cos(angle) * xrad1) + x_centre;
                        int x2 = (int) (Math.cos(angle) * xrad2) + x_centre;
                        int y1 = -(int) (Math.sin(angle) * yrad1) + y_centre;
                        int y2 = -(int) (Math.sin(angle) * yrad2) + y_centre;
                        g.drawLine(x1, y1, x2, y2);
                    }
                    
                    if (i == width - 1) {
                        angle += (double) (sect_angle) * deg_to_rad;
                        if (maze.IsWall(i, j, Walls.East)) {
                            int xrad1 = r.width / 2 - (j * x_sect);
                            int xrad2 = xrad1 - x_sect;
                            
                            int x1 = xrad1 + x_centre;
                            int x2 = xrad2 + x_centre;
                            int y1 = y_centre;
                            int y2 = y_centre;
                            g.drawLine(x1, y1, x2, y2);
                        }
                    }
                }
            }
             g2.setStroke(oldStroke);

            // Draw the solution if required
            Iterator<Point> iter = maze.iterator();
            if (chkShowSolution.getState() && iter.hasNext()) {
                // draw solution in red
                g.setColor(Color.RED);

                // The maze iterator is set to iterate the solution line from exit to entrance
                Point p1 = iter.next();
                Point p2;
                
                while (iter.hasNext()) {
                    p2 = iter.next();
                    
                    // Is this a line going inward/outward or around the maze
                    if (p1.x == p2.x) {
                        // Inward/Outward
                        // Calculate the line co-ordinates
                        int xrad1 = r.width / 2 - (Math.max(p1.y, p2.y) * x_sect) + x_sect / 2;
                        int xrad2 = xrad1 - x_sect;
                        int yrad1 = r.height / 2 - (Math.max(p1.y, p2.y) * y_sect) + y_sect / 2;
                        int yrad2 = yrad1 - y_sect;
                        double angle = (((double) (p1.x) * sect_angle) + sect_angle / 2) * deg_to_rad;
                                               
                        int x1 = (int) (Math.cos(angle) * xrad1) + x_centre;
                        int x2 = (int) (Math.cos(angle) * xrad2) + x_centre;
                        int y1 = -(int) (Math.sin(angle) * yrad1) + y_centre;
                        int y2 = -(int) (Math.sin(angle) * yrad2) + y_centre;
                        
                        g.drawLine(x1, y1, x2, y2);
                    } else {
                        // Line going around the maze
                        // handle wpossible rap around
                        int base_angle = Math.min(p1.x, p2.x);
                        if (Math.max(p1.x,p2.x) == width -1 && base_angle == 0){
                                base_angle = -1;
                        }
                        
                        g.drawArc(p1.y * x_sect + rad_offset + x_sect / 2,
                                p1.y * y_sect + rad_offset + y_sect / 2,
                                r.width - (2 * p1.y * x_sect) - x_sect,
                                r.height - (2 * p1.y * y_sect) - y_sect,
                                (int) (base_angle * sect_angle+sect_angle/2), 
                                (int) (sect_angle + 0.5));
                        }
                        p1 = p2;
                }
            }
        }
        
        // Draw a rectangular maze
        private void DrawRectangular(Graphics g) {
            g.setColor(Color.BLACK);
            
            // Get the drawing rectangle
            Rectangle r = g.getClipBounds();
            
            // get the height oand wisth of the maze (cells)
            int width = maze.getWidth();
            int height = maze.getHeight();
            
            // Get the height and width of a cell, defalte the square slightly
            //  so the maze if fully drawn on the panel
            int cellwidth = (r.width - DEFLATE*2) / width;
            int cellheight = (r.height - DEFLATE*2) / height;
            
            // Set the line width 
            Graphics2D g2 = (Graphics2D) g;
            Stroke oldStroke = g2.getStroke();
            g2.setStroke(new BasicStroke(3));
            
            // For each cell
            for (int i = 0; i < width; i++) {
                for (int j = 0; j < height; j++) {
                    
                    // Draw the north wall
                    if (maze.IsWall(i, j, Walls.North)) {
                        g.drawLine(DEFLATE + cellwidth * i, DEFLATE + cellheight * j,
                                DEFLATE + cellwidth * (i + 1), DEFLATE + cellheight * j);
                    }
                    
                    // On last row draw the south wall
                    if (j == (height - 1)) {
                        if (maze.IsWall(i, j, Walls.South)) {
                            g.drawLine(DEFLATE + cellwidth * i, DEFLATE + cellheight * (j + 1),
                                    DEFLATE + cellwidth * (i + 1), DEFLATE + cellheight * (j + 1));
                            
                        }
                    }
                    
                    // Draw the west wall
                    if (maze.IsWall(i, j, Walls.West)) {
                        g.drawLine(DEFLATE + cellwidth * i, DEFLATE + cellheight * j,
                                DEFLATE + cellwidth * i, DEFLATE + cellheight * (j + 1));
                    }
                    
                    // On the last column. draw the west wall
                    if (i == width - 1) {
                        if (maze.IsWall(i, j, Walls.East)) {
                            g.drawLine(DEFLATE + cellwidth * (i + 1), DEFLATE + cellheight * j,
                                    DEFLATE + cellwidth * (i + 1), DEFLATE + cellheight * (j + 1));
                        }
                    }
                    
                }
            }
            g2.setStroke(oldStroke);

            // Draw the solution if required
            Iterator<Point> iter = maze.iterator();
            if (chkShowSolution.getState() && iter.hasNext()) {
                // Draw solution in red
                g.setColor(Color.RED);

                // The maze iterator is set to iterate the solution line from exit to entrance
                Point p1 = iter.next();
                Point p2;
                
                // For each pair of point draw the line
                while (iter.hasNext()) {
                    p2 = iter.next();
                    
                    g.drawLine(DEFLATE + cellwidth * p1.x + cellwidth / 2,
                            DEFLATE + cellheight * p1.y + cellheight / 2,
                            DEFLATE + cellwidth * p2.x + cellwidth / 2,
                            DEFLATE + cellheight * p2.y + cellheight / 2);
                    
                    p1 = p2;
                }
            }
        }
    }

    // variables
    
    //Help text (using HTML as the control will auto-word-wrap HTML)
    final private String RectHelp = "<HTML>A rectangular maze can have a height and width between 5 and 25";
    final private String CircHelp = "<HTML>A circular maze can have a 15 to 30 radials and 4 to 8 layers";
    
    final static int DEFLATE = 5;
    Maze maze = new Maze();

    // Variables declaration - do not modify//GEN-BEGIN:variables
    private java.awt.Button btn3D;
    private java.awt.Button btnCreate;
    private javax.swing.ButtonGroup buttonGroup1;
    private java.awt.Checkbox chkShowSolution;
    private javax.swing.JRadioButton jCircButton;
    private javax.swing.JLabel jHelpText;
    private javax.swing.JLabel jLabel1;
    private javax.swing.JLabel jLabel2;
    private javax.swing.JLabel jLabel3;
    private javax.swing.JLabel jLabel4;
    private javax.swing.JPanel jPanel1;
    private javax.swing.JRadioButton jRectButton;
    private java.awt.TextField textHeight;
    private java.awt.TextField textLayers;
    private java.awt.TextField textRadials;
    private java.awt.TextField textWidth;
    // End of variables declaration//GEN-END:variables
}
